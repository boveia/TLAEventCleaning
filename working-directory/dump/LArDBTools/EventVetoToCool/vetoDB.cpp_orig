#include "vetoDB.h"
#include "CoolApplication/DatabaseSvcFactory.h"
#include "CoolKernel/RecordSpecification.h"

#include <set>

const uint32_t noiseWord=0x1U<<15;
const uint32_t miniNoiseWord=0x1U<<16;
const uint32_t corruptedWord=0x80U<<24;

bool checkOverlaps(const std::vector<VetoRange_t>& vetoRanges) {

  bool failure=false;
  cool::ValidityKey lastIOVEnd=0;
  for (const auto& rg : vetoRanges) {
    if (rg.startTime<lastIOVEnd) {
      std::cout << "ERROR, found overlappig IOV" << std::endl;
      failure=true;
    }
    lastIOVEnd=rg.stopTime;
  }
  return failure;
}

 

VetoDB::VetoDB(const std::string& dbName, const std::string& fdName, const std::string& EStagName, const std::string& BKtagName, bool create) 
  : m_dbName(dbName), m_fdName(fdName),m_ESTagName(EStagName),m_BKTagName(BKtagName),m_dbOk(false),m_create(create) {

  //Open the database and do a few sanity checks
  if(create) {
    m_db = cool::DatabaseSvcFactory::databaseService().createDatabase(m_dbName);
    std::string desc="<timeStamp>time</timeStamp><addrHeader><address_header service_type=\"71\" clid=\"40774348\" /></addrHeader><typeName>AthenaAttributeList</typeName>";
    cool::RecordSpecification rspec = cool::RecordSpecification();
    rspec.extend("EventVeto",cool::StorageType::UInt32);
    cool::FolderSpecification spec(cool::FolderVersioning::MULTI_VERSION, rspec);
    m_db->createFolder(fdName,spec,desc, true);
    
  } else {
     this->open();
  }

  // Get folder description
  if (!m_db) return; //ERROR, failed to open 


  if (!m_db->existsFolder(m_fdName)) {
    std::stringstream errmsg;
    errmsg << " Folder " << m_fdName << " does not exist.";
#ifdef ERS_ERS_H
    daq::rc::BadVetoDB i(ERS_HERE, errmsg.str().c_str());
    ers::error(i);
#else
    std::cout << "ERROR: " << errmsg.str() << std::endl;
#endif
    return; //ERROR, folder doesn't exist
  }

  //Get folder specs
  cool::IFolderPtr folder=m_db->getFolder(m_fdName);
  m_spec=folder->payloadSpecification();

  if(create){
      //folder->tagCurrentHead(m_ESTagName);
      //folder->cloneTagAsUserTag(m_ESTagName,m_BKTagName);
  } else {
    //Check if tags exists
    const std::vector<std::string>& allTags=folder->listTags();

    std::string errmsg("Folder ");
    errmsg+=m_fdName + ", Tag(s) [ ";
    bool destinationTagNotFound=false;
    if (m_ESTagName.size()>0 && std::find(allTags.begin(),allTags.end(),m_ESTagName)==allTags.end()) {
      destinationTagNotFound=true;
      errmsg += m_ESTagName+" ";
    }
    if (std::find(allTags.begin(),allTags.end(),m_BKTagName)==allTags.end()) {
      errmsg += m_BKTagName+" ";
      destinationTagNotFound=true;
    }
    errmsg+="] not found";

    if (destinationTagNotFound) {
#ifdef ERS_ERS_H
      daq::rc::BadVetoDB i(ERS_HERE, errmsg.c_str());
      ers::error(i);
#else
      std::cout << "ERROR " << errmsg << std::endl;
#endif
      return; //ERROR, tags don't exists
    }//else if tag not found
  }

  m_dbOk=true; //DB looks ok if we reached this point

  //close database now, reopen if when needed
  m_db->closeDatabase();
  return;
}

VetoDB::~VetoDB(){
  this->close();
  if (s_verbose > 0) std::cout << "Database " << m_dbName << " now closed." << std::endl;
}

 bool VetoDB::open() {
   if (m_db && m_db->isOpen()) {
     if (s_verbose > 0) std::cout << "Database already open." << std::endl;
     return true;
   }

   try {
     m_db = cool::DatabaseSvcFactory::databaseService().openDatabase(m_dbName, false);     // true = read_only
     if (s_verbose > 0) std::cout << "Database " << m_dbName << " sucessfully opened." << std::endl;
   }
   catch (std::exception &ex) {
#ifdef ERS_ERS_H
     daq::rc::BadVetoDB i(ERS_HERE, ex.what());
     ers::error(i);
#else
     std::cout << "ERROR: Failed to connect to database " << m_dbName << std::endl;
     std::cout << ex.what() << std::endl;
#endif
     return false;
   }
   return true;
 }

void VetoDB::close() {
  if (m_db && m_db->isOpen()) m_db->closeDatabase();
  m_db=0;
}


void VetoDB::purgeRecentRanges(const uint64_t ignoreOlderThan) {

  std::vector<VetoRange_t> previousRecentRanges;
  previousRecentRanges.reserve(m_recentRanges.size());
  
  previousRecentRanges.swap(m_recentRanges);


  for (const VetoRange_t& rg : previousRecentRanges) {
    if (rg.startTime>ignoreOlderThan) m_recentRanges.push_back(rg);
  }

  return;
} 

void VetoDB::purgeDuplicateRanges(std::vector<VetoRange_t>& inputRanges) const {

  std::vector<VetoRange_t> purged;
  purged.reserve(inputRanges.size());

  if (m_recentRanges.size()==0) {
    purged=inputRanges;
  }
  else {
    //Compare every input range with every recent range to find duplicates
    for (const VetoRange_t& input : inputRanges) {
      bool drop=false;
      for (const VetoRange_t& recent : m_recentRanges) {
	if (recent.startTime <= input.startTime && recent.stopTime >= input.stopTime) { // this input range is completly contained 
	  if (s_verbose) std::cout << "Veto range " << input.startTime << " - " << input.stopTime 
				   << " competly overlapping with recently uploaded veto range" << std::endl;
	  drop=true;
	  break;
	}
      }//end inner loop
      if (!drop) purged.push_back(input);
    }//end outer loop
  } // end size!=0

  
  inputRanges.swap(purged);
  return;
} 

std::vector<VetoRange_t> VetoDB::handleOverlaps(const std::vector<VetoRange_t>& ranges_std, const std::vector<VetoRange_t>& ranges_mnb, const std::vector<VetoRange_t>& ranges_cc) const {

  std::vector<VetoRange_t> result;

  if(ranges_std.size()==0 && ranges_mnb.size()==0 && ranges_cc.size()==0) return result;

  std::vector<VetoRange_t> tmpres = handleOverlaps2(ranges_std, ranges_mnb);

  result = handleOverlaps2(tmpres, ranges_cc);

  return result;
}

std::vector<VetoRange_t> VetoDB::handleOverlaps2(const std::vector<VetoRange_t>& ranges1, const std::vector<VetoRange_t>& ranges2) const {

 std::vector<VetoRange_t> result;
 if(ranges1.size()==0 && ranges2.size()==0) return result;
 if(ranges1.size()==0) { result = ranges2; return result;}
 if(ranges2.size()==0) { result = ranges1; return result;}
 
 //unsigned counter=0;
 result.reserve(ranges1.size()+ranges2.size());

 //std::vector<VetoRange_t>::iterator ic1=ranges1_tmp.begin();
 //std::vector<VetoRange_t>::iterator ie1=ranges1_tmp.end();
 //std::vector<VetoRange_t>::iterator ic2=ranges2_tmp.begin();
 //std::vector<VetoRange_t>::iterator ie2=ranges2_tmp.end();
 std::vector<VetoRange_t>::const_iterator ib1=ranges1.begin();
 std::vector<VetoRange_t>::const_iterator ib2=ranges2.begin();
 std::vector<VetoRange_t>::const_iterator ie1=ranges1.end();
 std::vector<VetoRange_t>::const_iterator ie2=ranges2.end();
 --ie1; --ie2; // to point to a last element
 if (s_verbose) {
     std::cout<<" handleOverlaps2, ranges1 size: "<<ranges1.size()<<" ranges2 size: "<<ranges2.size()<<std::endl;
     //std::cout<<(*ib).startTime<<" "<<ranges2_tmp.begin()->startTime<<std::endl;
 } 
 uint64_t currtime, nexttime,lasttime;
 uint8_t currflag=0, origflag=0;
 unsigned pflag, ppflag;
 std::vector<unsigned> currIndices;
 if ( (*ie2).startTime < (*ie1).startTime) lasttime = (*ie2).startTime; else lasttime = (*ie1).startTime;
 if ( (*(ib2)).stopTime > (*(ib1)).stopTime) {
      currtime = (*ib2).stopTime; currflag = (*ib2).flag; currIndices = (*ib2).evtIndices;
 } else {
      currtime = (*ib1).stopTime; currflag = (*ib1).flag; currIndices = (*ib1).evtIndices;
 }
 pflag=currflag;
 if (s_verbose) std::cout<<"Starting loop, currtime: "<<currtime<<" currflag: 0x"<<std::hex<<pflag<<std::dec<<" lasttime: "<<lasttime<<std::endl;
 std::set<uint64_t> sset;
 while(currtime > lasttime) {
    // if currtime start time of the previous period ?  If yes remove it's flag from currflag
    //if(currtime == (*(ib1-1)).startTime || currtime == (*(ib2-1)).startTime) currflag = 0 ; 
    pflag=currflag;
    ppflag=0;
    if(currtime == (*(ib1-1)).startTime) ppflag = (*(ib1-1)).flag; 
    if(currtime == (*(ib2-1)).startTime) ppflag = (*(ib2-1)).flag; 
    pflag -= ppflag;
    currflag = pflag; 
    if (s_verbose) std::cout<<" handleOverlaps2 currtime: "<<currtime<<" currflag: 0x"<<std::hex<<pflag<<", removed: 0x"<<ppflag<<std::dec<<std::endl;
    // find next range border in time
    sset.clear();
    if(ie1>=ib1) {sset.insert((*ib1).startTime); sset.insert((*ib1).stopTime);}
    if(ie2>=ib2) {sset.insert((*ib2).startTime); sset.insert((*ib2).stopTime);}
    std::set<uint64_t>::iterator sset_end=sset.end();
    --sset_end; // this should be currtime, or currtime is start of the previously used interval, if not something is wrong !!!
    //if(currtime != *sset_end && (*(ib1-1)).startTime != currtime && (*(ib2-1)).startTime != currtime  ) {
    if(currtime != *sset_end && (*(ib1-1)).startTime != currtime && (*(ib2-1)).startTime != currtime 
       && *sset_end != (*(ib1)).stopTime && *sset_end != (*(ib2)).stopTime ) {
          std::cout<<"Something wrong in sorting, aborting overlap handling !!"<<std::endl;
          std::cout<<"  *sset_end "<< *sset_end << " (ib1-1)).startTime "<<(*(ib1-1)).startTime<<" (ib2-1).startTime "<<(*(ib2-1)).startTime<<std::endl;
          std::cout<<(*ib1).startTime<<" "<<(*ib1).stopTime<<"    "<<(*ib2).startTime<<" "<<(*ib2).stopTime<<std::endl;
          return result;
    }
    if(currtime ==  *sset_end || (sset.find(currtime) == sset.end() && currtime < *sset_end) ) {--sset_end;}
    else if ( (*sset_end == (*ib2).stopTime || *sset_end == (*ib1).stopTime) &&
              ((currtime == (*ib2).stopTime || currtime == (*ib1).stopTime) ))
              {--sset_end; --sset_end;}// this is our new veto interval start
    nexttime = *sset_end;
    // is nextime start of some veto range ? if yes needs to add it's flag to current (if it is not there yet)
    if(nexttime == (*ib1).startTime) {
        if((currflag & (*ib1).flag) == 0) {currflag = currflag | (*ib1).flag; currIndices = (*ib1).evtIndices;}
        ++ib1;
    }
    if(nexttime == (*ib2).startTime) {
        if((currflag & (*ib2).flag) == 0) {currflag = currflag | (*ib2).flag; currIndices = (*ib2).evtIndices;}
        ++ib2;
    }
    // if both nextime and currtime are end of some veto range, add flag of those, which is later
    if( (nexttime == (*ib1).stopTime || nexttime == (*ib2).stopTime) &&
        (currtime == (*ib1).stopTime || currtime == (*ib2).stopTime) ) {

       if((*ib1).stopTime > (*ib2).stopTime) { 
             currflag = currflag | (*ib1).flag; currIndices = (*ib1).evtIndices;
       } else {
             currflag = currflag | (*ib2).flag; currIndices = (*ib2).evtIndices;
       }
    }

    pflag=currflag;
    if (s_verbose) std::cout<<"sset: ";
    std::set<uint64_t>::iterator sset_it=sset.begin();
    for(;sset_it != sset.end(); ++sset_it) std::cout<<*sset_it<<" ";
    std::cout<<std::endl;
    if (s_verbose) std::cout<<"Nextime: "<<nexttime<<" currflag: "<<std::hex<<pflag<<std::dec<<std::endl;
    // if currflag is not 0, build a veto period
    if(currflag != 0) {
       result.emplace(result.begin(), nexttime, currtime, currflag, std::move(currIndices));
       if (s_verbose) std::cout<<" handleOverlaps2 writing VetoRange: "<<nexttime<<" "<<currtime<<" : 0x"<<std::hex<<pflag<<std::dec<<std::endl;
    }
    currtime=nexttime;
    currIndices.clear();
 }
 // Remember, first element in vector is latest veto period
 /* This doesnt work
 for (; ib!=ie; ++ib) {
    std::vector<VetoRange_t>::iterator ib2=ranges2_tmp.begin();
    if ((*ib2).startTime <= (*ib).startTime && (*ib2).stopTime <= (*ib).stopTime) { // r2 is completely before, take r1 into results 
           result.emplace_back(*ib);
           if (s_verbose) std::cout<<" Option 1, 2 ranges put to result, ranges2_tmp size: "<<ranges2_tmp.size()<<std::endl;
    }
    else if ((*ib2).startTime == (*ib).startTime && (*ib2).stopTime == (*ib).stopTime) { // exactly overlapping ranges, put into results and remove from ranges2_tmp
           result.emplace_back((*ib).startTime, (*ib).stopTime, ((*ib).flag|(*ib2).flag),std::move((*ib).evtIndices));
           ranges2_tmp.erase(ib2);
           ++counter;
           if (s_verbose) std::cout<<" Option 2, 1 range put to result, ranges2_tmp size: "<<ranges2_tmp.size()<<std::endl;
    }
    else if ((*ib2).startTime >= (*ib).startTime && (*ib2).stopTime >= (*ib).stopTime) { // r2 is completely after, take both into results and remove from ranges2_tmp
           result.emplace_back(*ib2);
           result.emplace_back(*ib);
           ranges2_tmp.erase(ib2);
           if (s_verbose) std::cout<<" Option 3, 1 range put to result, ranges2_tmp size: "<<ranges2_tmp.size()<<std::endl;
    }        
    else if ((*ib2).startTime >= (*ib).startTime && (*ib2).stopTime <= (*ib).stopTime) { // r2 is completely inside r1, create 3 ranges to result, remove r2 from ranges2_tmp
           result.emplace_back((*ib2).stopTime,(*ib).stopTime,(*ib).flag,std::move((*ib).evtIndices));
           result.emplace_back((*ib2).startTime,(*ib2).stopTime,((*ib).flag|(*ib2).flag),std::move((*ib2).evtIndices));
           result.emplace_back((*ib).startTime, (*ib2).startTime,(*ib).flag,std::move((*ib).evtIndices));
           ranges2_tmp.erase(ib2);
           ++counter;
           if (s_verbose) std::cout<<" Option 4, 2 ranges put to result, ranges2_tmp size: "<<ranges2_tmp.size()<<std::endl;
    }
    else if ((*ib2).startTime <= (*ib).startTime && (*ib2).stopTime >= (*ib).stopTime) { // r1 is completely inside r2, create 3 ranges to result, remove r2 from ranges2_tmp
           result.emplace_back((*ib).stopTime, (*ib2).stopTime, (*ib2).flag,std::move((*ib2).evtIndices));
           result.emplace_back((*ib).startTime, (*ib).stopTime, ((*ib).flag|(*ib2).flag),std::move((*ib).evtIndices)); 
           result.emplace_back((*ib2).startTime, (*ib).startTime, (*ib2).flag,std::move((*ib2).evtIndices));
           ranges2_tmp.erase(ib2);
           ++counter;
           if (s_verbose) std::cout<<" Option 5, 2 ranges put to result, ranges2_tmp size: "<<ranges2_tmp.size()<<std::endl;
    }
    else if ((*ib2).startTime <= (*ib).startTime && (*ib2).stopTime <= (*ib).stopTime) { // r2 is overlaping r1 on front, create 3 ranges to result, remove r2 from ranges2_tmp
           result.emplace_back((*ib2).stopTime,(*ib).stopTime,(*ib).flag,std::move((*ib).evtIndices));
           result.emplace_back((*ib).startTime,(*ib2).stopTime,((*ib).flag|(*ib2).flag),std::move((*ib).evtIndices));
           result.emplace_back((*ib2).startTime,(*ib).startTime,(*ib2).flag,std::move((*ib2).evtIndices));
           ranges2_tmp.erase(ib2);
           ++counter;
           if (s_verbose) std::cout<<" Option 6, 2 ranges put to result, ranges2_tmp size: "<<ranges2_tmp.size()<<std::endl;
    } 
    else if ((*ib2).startTime >= (*ib).startTime && (*ib2).stopTime >= (*ib).stopTime) { // r2 is overlaping r1 on back, create 3 ranges to result, remove r2 from ranges2_tmp
           result.emplace_back((*ib).stopTime,(*ib2).stopTime,(*ib2).flag,std::move((*ib2).evtIndices));
           result.emplace_back((*ib2).startTime,(*ib).stopTime,((*ib).flag|(*ib2).flag),std::move((*ib).evtIndices));
           result.emplace_back((*ib).startTime,(*ib2).startTime,(*ib).flag,std::move((*ib).evtIndices));
           ranges2_tmp.erase(ib2);
           ++counter;
           if (s_verbose) std::cout<<" Option 7, 2 ranges put to result, ranges2_tmp size: "<<ranges2_tmp.size()<<std::endl;
    } 
    else {    // should never get here
        std::cout<<" ERROR resolving overlaps ! "<<std::endl;
        //std::cout<<(*ib).startTime<<" "<<(*ib).stopTime<<" | "<<(*ib2).startTime<<" "<<(*ib2).stopTime<<std::endl;
        //std::cout<<(*ib).startTime - (*ib2).startTime << " || "<<(*ib).stopTime - (*ib2).stopTime<<std::endl;
    }
 } // over first vector
 if (s_verbose > 0) {
    std::cout<<" Resolved: "<<counter<<" overlaps..."<<std::endl;
    std::cout<<result.size()<<" periods created"<<std::endl;
 }
*/
 return result;
}

bool VetoDB::store(std::vector<VetoRange_t>& vetoRanges) {

  if (vetoRanges.size()==0) return true; //Do nothing if no input

  //purge any duplicate ranges 
  
  purgeDuplicateRanges(vetoRanges);

  const cool::ChannelId chId(0);

  if (!this->open()) {
    std::cout << "ERROR while uploading: Failed to open destination database!" << std::endl;
    return false;
  }

  cool::IFolderPtr folder=m_db->getFolder(m_fdName);

  if (s_verbose) std::cout << "Start writing ..." << std::endl;

  cool::Record payload(folder->payloadSpecification()); //FIXME, can we re-use the same obj?
  //try:
  //catch
  for (const auto& rg : vetoRanges) {
    if (s_verbose) std::cout << "IOV start: " << rg.startTime << ", length " << rg.stopTime-rg.startTime << ", nEvents=" << rg.evtIndices.size() << std::endl; 
    cool:: HvsTagLock::Status lockstat;
    uint32_t vetoWord=0U;
    if(0x2 & rg.flag) vetoWord |= noiseWord;
    if(0x30 & rg.flag) vetoWord |= miniNoiseWord; //0x20 is MININOISEBURSTTIGHT and it is accompanied with 0x10 MININOISEBURSTLOOSE
    if(0x80 &rg.flag) vetoWord |= corruptedWord;
    if(!vetoWord) {
          unsigned int uf=rg.flag;
          std::cout << "Wrong flag 0x"<<std::hex<<uf<<std::dec<<" NOT WRITING !! "<<std::endl; 
          continue;
    }
    payload["EventVeto"].setValue(vetoWord);
    try {
      //1. Store data for express processing
      if(m_ESTagName.size() > 0) {
         if(m_create) {
            folder->storeObject(rg.startTime,rg.stopTime,payload,chId,m_ESTagName);      //Store data with folder-level tag for express processing
         } else {
            lockstat=folder->tagLockStatus(m_ESTagName);                                                                  //Remember previous locking state
            if (lockstat!=cool::HvsTagLock::UNLOCKED) folder->setTagLockStatus(m_ESTagName,cool::HvsTagLock::UNLOCKED);   //Set the lock state to unlock
            folder->storeObject(rg.startTime,rg.stopTime,payload,chId,m_ESTagName);      //Store data with folder-level tag for express processing
            if (lockstat!=cool::HvsTagLock::UNLOCKED) folder->setTagLockStatus(m_ESTagName,lockstat);                     //Relock if it was locked before
         }
      }


      //2. Store the same for bulk processing
      if(m_BKTagName.size() > 0) {
       if(m_create) {
         folder->storeObject(rg.startTime,rg.stopTime,payload,chId,m_BKTagName);      //Store data with folder-level tag for bulk processing
       } else {
        lockstat=folder->tagLockStatus(m_BKTagName);                                                                  //Remember previous locking state
        if (lockstat!=cool::HvsTagLock::UNLOCKED) folder->setTagLockStatus(m_BKTagName,cool::HvsTagLock::UNLOCKED);   //Set the lock-state to unlock
        folder->storeObject(rg.startTime,rg.stopTime,payload,chId,m_BKTagName);      //Store data with folder-level tag for bulk processing
        if (lockstat!=cool::HvsTagLock::UNLOCKED) folder->setTagLockStatus(m_BKTagName,lockstat);                     //Relock if it was locked before
       }
     }
    }
    catch (...) {
#ifdef ERS_ERS_H
      daq::rc::BadVetoDB i(ERS_HERE, "Exception caught while uploading to database. Will retry later");
      ers::error(i);
#else
      std::cout << "ERROR: Exception caught while uploading to database. Will retry later" << std::endl;
#endif
      return false;
    }
    m_recentRanges.push_back(rg);
  }//end loop over ranges
  return true;
}

bool VetoDB::storeToSqlite(const std::vector<VetoRange_t>& vetoRanges, const std::string& sqlitelocation) const {
  
  const std::string descr="<timeStamp>time</timeStamp><addrHeader><address_header service_type=\"71\" clid=\"40774348\" /></addrHeader><typeName>AthenaAttributeList</typeName>";
  
  cool::RecordSpecification spec;
  spec.extend("EventVeto",cool::StorageType::UInt32);
  
  cool::FolderSpecification folderSpec(cool::FolderVersioning::MULTI_VERSION,spec);

  //char sqlitespec[1024];
  //snprintf(sqlitespec,1023,"sqlite://;schema=%s;dbname=CONDBR2",sqlitelocation);
  //sqlitespec[1023]='\0'; 

  std::string sqlitespec=std::string("sqlite://;schema=")+sqlitelocation+";dbname=CONDBR2";

  cool::IDatabasePtr sqDB= cool::DatabaseSvcFactory::databaseService().createDatabase(sqlitespec); 
  if (sqDB  && sqDB->isOpen())
    if (s_verbose) std::cout << "Successfully opend sqlite " << sqlitespec << std::endl;
  else {
    std::cout << "ERROR, failed to open sqlite file " << sqlitespec << std::endl;
    return false;
  }

  
  cool::IFolderPtr folder;
  if (sqDB->existsFolder(m_fdName))
    folder=sqDB->getFolder(m_fdName);
  else
    folder=sqDB->createFolder(m_fdName,folderSpec,descr,true);
 
  const cool::ChannelId chId(0);
  cool::Record payload(spec); //FIXME, can we re-use the same obj?


  for (const auto& rg : vetoRanges) {
    if (s_verbose) std::cout << "IOV start: " << rg.startTime << ", length " << rg.stopTime-rg.startTime << ", nEvents=" << rg.evtIndices.size() << std::endl; 
    uint32_t vetoWord=0U;
    if(0x2 & rg.flag) vetoWord |= noiseWord; 
    if(0x20 & rg.flag) vetoWord |= miniNoiseWord; 
    if(0x80 & rg.flag) vetoWord |= corruptedWord; 
    if(!vetoWord) {
          unsigned int uf=rg.flag;
          std::cout << "Wrong flag 0x"<<std::hex<<uf<<std::dec<<" NOT WRITING !! "<<std::endl; 
          continue;
    }
    payload["EventVeto"].setValue(vetoWord);
    try {
      folder->storeObject(rg.startTime,rg.stopTime,payload,chId,m_BKTagName);  //Store data with folder-level tag for bulk processing
    }
    catch (...) {
#ifdef ERS_ERS_H
      daq::rc::BadVetoDB i(ERS_HERE, "Exception caught while uploading to sqlite backup.");
      ers::error(i);
#else
      std::cout << "ERROR: Exception caught while uploading to sqlite backup." << std::endl;
#endif
      return false;
    }
  }

  sqDB->closeDatabase();
  return true;
}
